# Bench files

defines.FRAGMENT_SIZE = 32
defines.CRYSTAL_SIZE = 512

[cases.bench_files]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
defines.SIZE = 16384
defines.CHUNK = 64
defines.SEED = 42
defines.REWRITE = [false, true]
defines.SYNC = true
in = 'lfs.c'
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, CFG) => 0;
    lfsr_mount(&lfs, CFG) => 0;
    uint32_t prng = SEED;

    // find the baseline usage after format
    uint8_t *usage_bmap = malloc((BLOCK_COUNT+8-1)/8);
    memset(usage_bmap, 0, (BLOCK_COUNT+8-1)/8);
    lfsr_traversal_t traversal = LFSR_TRAVERSAL(LFSR_TRAVERSAL_ALL);
    while (true) {
        lfsr_tinfo_t tinfo;
        int err = lfsr_traversal_read(&lfs, &traversal, &tinfo);
        assert(!err || err == LFS_ERR_NOENT);
        if (err == LFS_ERR_NOENT) {
            break;
        }

        if (tinfo.tag == LFSR_TAG_MDIR) {
            usage_bmap[tinfo.u.mdir.u.m.blocks[0]/8]
                    |= 1 << (tinfo.u.mdir.u.m.blocks[0] % 8);
            usage_bmap[tinfo.u.mdir.u.m.blocks[1]/8]
                    |= 1 << (tinfo.u.mdir.u.m.blocks[1] % 8);
        } else if (tinfo.tag == LFSR_TAG_BRANCH) {
            usage_bmap[tinfo.u.rbyd.block/8]
                    |= 1 << (tinfo.u.rbyd.block % 8);
        } else if (tinfo.tag == LFSR_TAG_BLOCK) {
            usage_bmap[tinfo.u.bptr.block/8]
                    |= 1 << (tinfo.u.bptr.block % 8);
        }
    }
    lfs_size_t usage_baseline = 0;
    for (lfs_size_t j = 0; j < BLOCK_COUNT; j++) {
        if (usage_bmap[j / 8] & (1 << (j % 8))) {
            usage_baseline += 1;
        }
    }

    // create an initial file to rewrite?
    if (REWRITE) {
        lfsr_file_t file;
        lfsr_file_open(&lfs, &file, "bench_file",
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_TRUNC) => 0;
        for (lfs_size_t i = 0; i < (SIZE+(CHUNK-1))/CHUNK; i++) {
            uint8_t wbuf[CHUNK];
            for (lfs_size_t j = 0; j < CHUNK; j++) {
                wbuf[j] = 'a' + (BENCH_PRNG(&prng) % 26);
            }
            lfsr_file_write(&lfs, &file, wbuf, CHUNK) => CHUNK;
        }
        lfsr_file_close(&lfs, &file) => 0;
    }

    // write our file
    lfsr_file_t file;
    lfsr_file_open(&lfs, &file, "bench_file",
            LFS_O_RDWR | LFS_O_CREAT) => 0;
    for (lfs_size_t i = 0; i < (SIZE+(CHUNK-1))/CHUNK; i++) {
        lfs_off_t i_
                = (ORDER == 0) ? i
                : (ORDER == 1) ? ((SIZE+(CHUNK-1))/CHUNK)-1-i
                : BENCH_PRNG(&prng) % ((SIZE+(CHUNK-1))/CHUNK);

        BENCH_START("write", i*CHUNK, CHUNK);
        // seek to where we want to write
        lfsr_file_seek(&lfs, &file, i_*CHUNK, LFS_SEEK_SET) => i_*CHUNK;

        // actually write
        uint8_t wbuf[CHUNK];
        for (lfs_size_t j = 0; j < CHUNK; j++) {
            wbuf[j] = 'a' + (BENCH_PRNG(&prng) % 26);
        }
        lfsr_file_write(&lfs, &file, wbuf, CHUNK) => CHUNK;

        // sync?
        if (SYNC) {
            lfsr_file_sync(&lfs, &file) => 0;
        }
        BENCH_STOP("write");

        // measure a random chunk-sized read
        BENCH_START("read", i*CHUNK, CHUNK);
        i_ = BENCH_PRNG(&prng) % (lfsr_file_size(&lfs, &file) / CHUNK);
        lfsr_file_seek(&lfs, &file, i_*CHUNK, LFS_SEEK_SET) => i_*CHUNK;

        uint8_t rbuf[CHUNK];
        lfsr_file_read(&lfs, &file, rbuf, CHUNK) => CHUNK;
        BENCH_STOP("read");

        // find the usage
        //
        // our files are copy-on-write, so we need to build a bitmap to get
        // the true disk usage
        memset(usage_bmap, 0, (BLOCK_COUNT+8-1)/8);
        traversal = LFSR_TRAVERSAL(LFSR_TRAVERSAL_ALL);
        while (true) {
            lfsr_tinfo_t tinfo;
            int err = lfsr_traversal_read(&lfs, &traversal, &tinfo);
            assert(!err || err == LFS_ERR_NOENT);
            if (err == LFS_ERR_NOENT) {
                break;
            }

            if (tinfo.tag == LFSR_TAG_MDIR) {
                usage_bmap[tinfo.u.mdir.u.m.blocks[0]/8]
                        |= 1 << (tinfo.u.mdir.u.m.blocks[0] % 8);
                usage_bmap[tinfo.u.mdir.u.m.blocks[1]/8]
                        |= 1 << (tinfo.u.mdir.u.m.blocks[1] % 8);
            } else if (tinfo.tag == LFSR_TAG_BRANCH) {
                usage_bmap[tinfo.u.rbyd.block/8]
                        |= 1 << (tinfo.u.rbyd.block % 8);
            } else if (tinfo.tag == LFSR_TAG_BLOCK) {
                usage_bmap[tinfo.u.bptr.block/8]
                        |= 1 << (tinfo.u.bptr.block % 8);
            }
        }
        lfs_size_t usage = 0;
        for (lfs_size_t j = 0; j < BLOCK_COUNT; j++) {
            if (usage_bmap[j / 8] & (1 << (j % 8))) {
                usage += 1;
            }
        }
        BENCH_RESULT("usage", i*CHUNK, REWRITE ? ((i == 0) ? SIZE : 0) : CHUNK,
                (uintmax_t)(usage - usage_baseline)
                    * (uintmax_t)CFG->block_size);
    }
    lfsr_file_close(&lfs, &file) => 0;

    free(usage_bmap);
    lfsr_unmount(&lfs) => 0;
'''

