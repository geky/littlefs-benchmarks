# Bench directory operations

[cases.bench_dirs]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
defines.N = 1024
defines.STEP = 1
defines.SEED = 42
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, CFG) => 0;
    lfsr_mount(&lfs, CFG) => 0;

    // create a filesystem with N dirs
    uint32_t prng = SEED;
    for (lfs_size_t i = 0; i < N; i++) {
        lfsr_mid_t i_
                = (ORDER == 0) ? i
                : (ORDER == 1) ? N-1-i
                : BENCH_PRNG(&prng) % N;
        char name[256];
        sprintf(name, "dir%05d", i_);

        if (i % STEP == 0) {
            BENCH_START("mkdir", i, STEP);
        }
        int err = lfsr_mkdir(&lfs, name);
        assert(!err || err == LFS_ERR_EXIST);
        if (i % STEP == 0) {
            BENCH_STOP("mkdir");
        }

        if (i % STEP == 0) {
            // measure stat
            BENCH_START("stat", i, STEP);
            lfsr_mid_t i_ = BENCH_PRNG(&prng) % N;
            sprintf(name, "dir%05d", i_);
            struct lfs_info info;
            int err = lfsr_stat(&lfs, name, &info);
            assert(!err || err == LFS_ERR_NOENT);
            if (!err) {
                assert(info.type == LFS_TYPE_DIR);
                assert(strcmp(info.name, name) == 0);
            }
            BENCH_STOP("stat");

            // measure dir reads
            BENCH_START("read", i, STEP);
            lfsr_dir_t dir;
            lfsr_dir_open(&lfs, &dir, "/") => 0;
            while (true) {
                int err = lfsr_dir_read(&lfs, &dir, &info);
                assert(!err || err == LFS_ERR_NOENT);
                if (err == LFS_ERR_NOENT) {
                    break;
                }

                assert(info.type == LFS_TYPE_DIR);
            }
            lfsr_dir_close(&lfs, &dir) => 0;
            BENCH_STOP("read");

            // measure disk usage
            lfs_soff_t count = lfsr_fs_size(&lfs);
            assert(count >= 0);
            BENCH_RESULT("usage", i, STEP,
                (uintmax_t)count * (uintmax_t)CFG->block_size);
        }
    }

    lfsr_unmount(&lfs) => 0;
'''
