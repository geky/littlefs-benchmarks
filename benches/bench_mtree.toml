# Bench our high-level metadata tree in the core of littlefs

# maximize lookahead buffer, we don't actually gc so we only get one pass
# of the disk for these tests
defines.LOOKAHEAD_SIZE = 'BLOCK_COUNT / 8'

[cases.bench_mtree]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
defines.N = 1024
defines.STEP = 1
defines.SEED = 42
defines.SIZE = 4
in = 'lfs.c'
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, CFG) => 0;
    lfsr_mount(&lfs, CFG) => 0;
    lfs_alloc_ack(&lfs);

    // create an mtree with N entries
    uint32_t prng = SEED;
    for (lfs_size_t i = 0; i < N; i++) {
        lfsr_mid_t i_
                = (ORDER == 0) ? i
                : (ORDER == 1) ? N-1-i
                : BENCH_PRNG(&prng) % N;
        char name[256];
        sprintf(name, "e%05d", i_);
        uint8_t wbuf[SIZE];
        memset(wbuf, 'a'+(BENCH_PRNG(&prng) % 26), SIZE);

        if (i % STEP == 0) {
            BENCH_START("commit", i, STEP);
        }
        lfsr_mdir_t mdir;
        lfsr_tag_t tag;
        lfsr_data_t data;
        int err = lfsr_mtree_namelookup(&lfs, &lfs.mtree,
                0, name, strlen(name),
                &mdir, &tag, &data);
        assert(!err || err == LFS_ERR_NOENT);
        // new entry?
        if (err == LFS_ERR_NOENT) {
            lfsr_mdir_commit(&lfs, &mdir, LFSR_ATTRS(
                    LFSR_ATTR(mdir.mid, REG, +1, CAT(
                        LFSR_DATA_LEB128(0),
                        LFSR_DATA_BUF(name, strlen(name)))),
                    LFSR_ATTR(mdir.mid, DATA, 0, BUF(wbuf, SIZE)))) => 0;
            
        // collision?
        } else {
            lfsr_mdir_commit(&lfs, &mdir, LFSR_ATTRS(
                    LFSR_ATTR(mdir.mid, DATA, 0, BUF(wbuf, SIZE)))) => 0;
        }
        if (i % STEP == 0) {
            BENCH_STOP("commit");
        }

        if (i % STEP == 0) {
            // measure name lookups
            BENCH_START("namelookup", i, STEP);
            lfsr_mid_t i_ = BENCH_PRNG(&prng) % N;
            sprintf(name, "e%05d", i_);
            lfsr_mdir_t mdir;
            lfsr_tag_t tag;
            lfsr_data_t data;
            int err = lfsr_mtree_namelookup(&lfs, &lfs.mtree,
                    0, name, strlen(name),
                    &mdir, &tag, &data);
            assert(!err || err == LFS_ERR_NOENT);
            if (!err) {
                assert(tag == LFSR_TAG_REG);
            }
            BENCH_STOP("namelookup");

            // measure mid lookups
            //
            // we use mid found by name lookup so we know mid is valid
            BENCH_START("lookup", i, STEP);
            lfsr_mtree_lookup(&lfs, &lfs.mtree, mdir.mid,
                    &mdir) => 0;
            BENCH_STOP("lookup");

            // measure traversal cost
            BENCH_START("traversal", i, STEP);
            lfsr_traversal_t traversal = LFSR_TRAVERSAL(0);
            while (true) {
                lfsr_tinfo_t tinfo;
                int err = lfsr_traversal_read(&lfs, &traversal,
                        &tinfo);
                assert(!err || err == LFS_ERR_NOENT);
                if (err == LFS_ERR_NOENT) {
                    break;
                }
            }
            BENCH_STOP("traversal");

            // measure disk usage
            lfs_off_t count = 0;

            traversal = LFSR_TRAVERSAL(0);
            while (true) {
                lfsr_tinfo_t tinfo;
                int err = lfsr_traversal_read(&lfs, &traversal,
                        &tinfo);
                assert(!err || err == LFS_ERR_NOENT);
                if (err == LFS_ERR_NOENT) {
                    break;
                }

                if (tinfo.tag == LFSR_TAG_MDIR) {
                    count += 2;
                } else if (tinfo.tag == LFSR_TAG_BRANCH) {
                    count += 1;
                }
            }

            BENCH_RESULT("usage", i, STEP,
                (uintmax_t)count * CFG->block_size);
        }
    }

    lfsr_unmount(&lfs) => 0;
'''
