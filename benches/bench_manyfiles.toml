# ignore shrub problems for now (WIP)
defines.CACHE_SIZE = 'lfs_max32(SIZE, 16)'

[cases.bench_manyfiles_create]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = 2
defines.N = 1024
defines.SIZE = [0, 16, 512]
defines.AMORTIZED = false
defines.SEED = 42
code = '''
    uint32_t prng = SEED;

    lfs_t lfs;
    lfsr_format(&lfs, CFG) => 0;
    lfsr_mount(&lfs, CFG) => 0;

    if (AMORTIZED) {
        BENCH_START();
    }

    // create each file
    for (lfs_size_t i = 0; i < N; i++) {
        if (!AMORTIZED && i == N-1) {
            BENCH_START();
        }

        lfs_size_t i_
                = (ORDER == 0) ? i
                : (ORDER == 1) ? N-1-i
                : BENCH_PRNG(&prng) % N;

        char name[512];
        sprintf(name, "file%04d", i_);

        lfsr_file_t file;
        lfsr_file_open(&lfs, &file, name,
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_TRUNC) => 0;
        uint8_t wbuf[SIZE];
        for (lfs_size_t j = 0; j < SIZE; j++) {
            wbuf[j] = 'a' + (BENCH_PRNG(&prng) % 26);
        }
        lfsr_file_write(&lfs, &file, wbuf, SIZE) => SIZE;
        lfsr_file_close(&lfs, &file) => 0;

        if (!AMORTIZED && i == N-1) {
            BENCH_STOP();
        }
    }

    if (AMORTIZED) {
        BENCH_STOP();
    }
'''

[cases.bench_manyfiles_read]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = 2
defines.N = 1024
defines.SIZE = [0, 16, 512]
defines.SEED = 42
code = '''
    uint32_t prng = SEED;

    lfs_t lfs;
    lfsr_format(&lfs, CFG) => 0;
    lfsr_mount(&lfs, CFG) => 0;

    // create each file
    for (lfs_size_t i = 0; i < N; i++) {
        lfs_size_t i_
                = (ORDER == 0) ? i
                : (ORDER == 1) ? N-1-i
                : BENCH_PRNG(&prng) % N;

        char name[512];
        sprintf(name, "file%04d", i_);

        lfsr_file_t file;
        lfsr_file_open(&lfs, &file, name,
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_TRUNC) => 0;
        uint8_t wbuf[SIZE];
        for (lfs_size_t j = 0; j < SIZE; j++) {
            wbuf[j] = 'a' + (BENCH_PRNG(&prng) % 26);
        }
        lfsr_file_write(&lfs, &file, wbuf, SIZE) => SIZE;
        lfsr_file_close(&lfs, &file) => 0;
    }

    // now read a random file
    BENCH_START();
    lfs_size_t i_ = BENCH_PRNG(&prng) % N;
    char name[512];
    sprintf(name, "file%04d", i_);

    lfsr_file_t file;
    int err = lfsr_file_open(&lfs, &file, name, LFS_O_RDONLY);
    assert(!err || err == LFS_ERR_NOENT);
    if (err != LFS_ERR_NOENT) {
        uint8_t rbuf[SIZE];
        lfsr_file_read(&lfs, &file, rbuf, SIZE) => SIZE;
        for (lfs_size_t j = 0; j < SIZE; j++) {
            assert(rbuf[j] >= 'a' && rbuf[j] <= 'z');
        }
        lfsr_file_close(&lfs, &file) => 0;
    }
    BENCH_STOP();
'''
